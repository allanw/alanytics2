import {
  __export
} from "./chunk-FAW2VN4A.js";

// ../../node_modules/@tidyjs/tidy/dist/es/tidy.js
function tidy(items, ...fns) {
  if (typeof items === "function") {
    throw new Error("You must supply the data as the first argument to tidy()");
  }
  let result = items;
  for (const fn of fns) {
    if (fn) {
      result = fn(result);
    }
  }
  return result;
}

// ../../node_modules/@tidyjs/tidy/dist/es/filter.js
function filter(filterFn) {
  const _filter = (items) => items.filter(filterFn);
  return _filter;
}

// ../../node_modules/@tidyjs/tidy/dist/es/when.js
function when(predicate, fns) {
  const _when = (items) => {
    if (typeof predicate === "function") {
      if (!predicate(items))
        return items;
    } else if (!predicate) {
      return items;
    }
    const results = tidy(items, ...fns);
    return results;
  };
  return _when;
}

// ../../node_modules/@tidyjs/tidy/dist/es/map.js
function map(mapFn) {
  const _map = (items) => items.map(mapFn);
  return _map;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/singleOrArray.js
function singleOrArray(d) {
  return d == null ? [] : Array.isArray(d) ? d : [d];
}

// ../../node_modules/@tidyjs/tidy/dist/es/distinct.js
function distinct(keys) {
  const _distinct = (items) => {
    keys = singleOrArray(keys);
    if (!keys.length) {
      const set2 = /* @__PURE__ */ new Set();
      for (const item of items) {
        set2.add(item);
      }
      return Array.from(set2);
    }
    const rootMap = /* @__PURE__ */ new Map();
    const distinctItems = [];
    const lastKey = keys[keys.length - 1];
    for (const item of items) {
      let map4 = rootMap;
      let hasItem = false;
      for (const key of keys) {
        const mapItemKey = typeof key === "function" ? key(item) : item[key];
        if (key === lastKey) {
          hasItem = map4.has(mapItemKey);
          if (!hasItem) {
            distinctItems.push(item);
            map4.set(mapItemKey, true);
          }
          break;
        }
        if (!map4.has(mapItemKey)) {
          map4.set(mapItemKey, /* @__PURE__ */ new Map());
        }
        map4 = map4.get(mapItemKey);
      }
    }
    return distinctItems;
  };
  return _distinct;
}

// ../../node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// ../../node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }
  function left(a, x, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a, x, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a, x, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x) => ascending_default(f(d), x);
}

// ../../node_modules/d3-array/src/number.js
function number_default(x) {
  return x === null ? NaN : +x;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// ../../node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;

// ../../node_modules/d3-array/src/variance.js
function variance(values, valueof) {
  let count3 = 0;
  let delta;
  let mean4 = 0;
  let sum3 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean4;
        mean4 += delta / ++count3;
        sum3 += delta * (value - mean4);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
        delta = value - mean4;
        mean4 += delta / ++count3;
        sum3 += delta * (value - mean4);
      }
    }
  }
  if (count3 > 1)
    return sum3 / (count3 - 1);
}

// ../../node_modules/d3-array/src/deviation.js
function deviation(values, valueof) {
  const v = variance(values, valueof);
  return v ? Math.sqrt(v) : v;
}

// ../../node_modules/d3-array/src/extent.js
function extent_default(values, valueof) {
  let min3;
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min3 === void 0) {
          if (value >= value)
            min3 = max3 = value;
        } else {
          if (min3 > value)
            min3 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null) {
        if (min3 === void 0) {
          if (value >= value)
            min3 = max3 = value;
        } else {
          if (min3 > value)
            min3 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  }
  return [min3, max3];
}

// ../../node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j], hi = x + y, lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo)
        p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n2 = this._n, x, y, lo, hi = 0;
    if (n2 > 0) {
      hi = p[--n2];
      while (n2 > 0) {
        x = hi;
        y = p[--n2];
        hi = x + y;
        lo = y - (hi - x);
        if (lo)
          break;
      }
      if (n2 > 0 && (lo < 0 && p[n2 - 1] < 0 || lo > 0 && p[n2 - 1] > 0)) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi)
          hi = x;
      }
    }
    return hi;
  }
};
function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index2, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

// ../../node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(value);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// ../../node_modules/d3-array/src/identity.js
function identity_default(x) {
  return x;
}

// ../../node_modules/d3-array/src/group.js
function group(values, ...keys) {
  return nest(values, identity_default, identity_default, keys);
}
function nest(values, map4, reduce2, keys) {
  return function regroup(values2, i) {
    if (i >= keys.length)
      return reduce2(values2);
    const groups2 = new InternMap();
    const keyof2 = keys[i++];
    let index2 = -1;
    for (const value of values2) {
      const key = keyof2(value, ++index2, values2);
      const group2 = groups2.get(key);
      if (group2)
        group2.push(value);
      else
        groups2.set(key, [value]);
    }
    for (const [key, values3] of groups2) {
      groups2.set(key, regroup(values3, i));
    }
    return map4(groups2);
  }(values, 0);
}

// ../../node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map2 = array.map;

// ../../node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// ../../node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}

// ../../node_modules/d3-array/src/min.js
function min(values, valueof) {
  let min3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  }
  return min3;
}

// ../../node_modules/d3-array/src/quickselect.js
function quickselect(array2, k, left = 0, right = array2.length - 1, compare = ascending_default) {
  while (right > left) {
    if (right - left > 600) {
      const n2 = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n2);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n2 - s) / n2) * (m - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n2 + sd));
      const newRight = Math.min(right, Math.floor(k + (n2 - m) * s / n2 + sd));
      quickselect(array2, k, newLeft, newRight, compare);
    }
    const t = array2[k];
    let i = left;
    let j = right;
    swap(array2, left, k);
    if (compare(array2[right], t) > 0)
      swap(array2, left, right);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0)
        ++i;
      while (compare(array2[j], t) > 0)
        --j;
    }
    if (compare(array2[left], t) === 0)
      swap(array2, left, j);
    else
      ++j, swap(array2, j, right);
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// ../../node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n2 = values.length))
    return;
  if ((p = +p) <= 0 || n2 < 2)
    return min(values);
  if (p >= 1)
    return max(values);
  var n2, i = (n2 - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

// ../../node_modules/d3-array/src/median.js
function median_default(values, valueof) {
  return quantile(values, 0.5, valueof);
}

// ../../node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/arrange.js
function arrange(comparators) {
  const _arrange = (items) => {
    const comparatorFns = singleOrArray(comparators).map((comp) => typeof comp === "function" ? comp.length === 1 ? asc(comp) : comp : asc(comp));
    return items.slice().sort((a, b) => {
      for (const comparator of comparatorFns) {
        const result = comparator(a, b);
        if (result)
          return result;
      }
      return 0;
    });
  };
  return _arrange;
}
function asc(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return function _asc(a, b) {
    return emptyAwareComparator(keyFn(a), keyFn(b), false);
  };
}
function desc(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return function _desc(a, b) {
    return emptyAwareComparator(keyFn(a), keyFn(b), true);
  };
}
function fixedOrder(key, order, options) {
  let { position = "start" } = options != null ? options : {};
  const positionFactor = position === "end" ? -1 : 1;
  const indexMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < order.length; ++i) {
    indexMap.set(order[i], i);
  }
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return function _fixedOrder(a, b) {
    var _a, _b;
    const aIndex = (_a = indexMap.get(keyFn(a))) != null ? _a : -1;
    const bIndex = (_b = indexMap.get(keyFn(b))) != null ? _b : -1;
    if (aIndex >= 0 && bIndex >= 0) {
      return aIndex - bIndex;
    }
    if (aIndex >= 0) {
      return positionFactor * -1;
    }
    if (bIndex >= 0) {
      return positionFactor * 1;
    }
    return 0;
  };
}
function emptyAwareComparator(aInput, bInput, desc2) {
  let a = desc2 ? bInput : aInput;
  let b = desc2 ? aInput : bInput;
  if (isEmpty(a) && isEmpty(b)) {
    const rankA = a !== a ? 0 : a === null ? 1 : 2;
    const rankB = b !== b ? 0 : b === null ? 1 : 2;
    const order = rankA - rankB;
    return desc2 ? -order : order;
  }
  if (isEmpty(a)) {
    return desc2 ? -1 : 1;
  }
  if (isEmpty(b)) {
    return desc2 ? 1 : -1;
  }
  return ascending_default(a, b);
}
function isEmpty(value) {
  return value == null || value !== value;
}

// ../../node_modules/@tidyjs/tidy/dist/es/summarize.js
function summarize(summarizeSpec, options) {
  const _summarize = (items) => {
    options = options != null ? options : {};
    const summarized = {};
    const keys = Object.keys(summarizeSpec);
    for (const key of keys) {
      summarized[key] = summarizeSpec[key](items);
    }
    if (options.rest && items.length) {
      const objectKeys = Object.keys(items[0]);
      for (const objKey of objectKeys) {
        if (keys.includes(objKey)) {
          continue;
        }
        summarized[objKey] = options.rest(objKey)(items);
      }
    }
    return [summarized];
  };
  return _summarize;
}
function _summarizeHelper(items, summaryFn, predicateFn, keys) {
  if (!items.length)
    return [];
  const summarized = {};
  let keysArr;
  if (keys == null) {
    keysArr = Object.keys(items[0]);
  } else {
    keysArr = [];
    for (const keyInput of singleOrArray(keys)) {
      if (typeof keyInput === "function") {
        keysArr.push(...keyInput(items));
      } else {
        keysArr.push(keyInput);
      }
    }
  }
  for (const key of keysArr) {
    if (predicateFn) {
      const vector = items.map((d) => d[key]);
      if (!predicateFn(vector)) {
        continue;
      }
    }
    summarized[key] = summaryFn(key)(items);
  }
  return [summarized];
}
function summarizeAll(summaryFn) {
  const _summarizeAll = (items) => _summarizeHelper(items, summaryFn);
  return _summarizeAll;
}
function summarizeIf(predicateFn, summaryFn) {
  const _summarizeIf = (items) => _summarizeHelper(items, summaryFn, predicateFn);
  return _summarizeIf;
}
function summarizeAt(keys, summaryFn) {
  const _summarizeAt = (items) => _summarizeHelper(items, summaryFn, void 0, keys);
  return _summarizeAt;
}

// ../../node_modules/@tidyjs/tidy/dist/es/mutate.js
function mutate(mutateSpec) {
  const _mutate = (items) => {
    const mutatedItems = [];
    for (const item of items) {
      const mutatedItem = { ...item };
      for (const key in mutateSpec) {
        const mutateSpecValue = mutateSpec[key];
        const mutatedResult = typeof mutateSpecValue === "function" ? mutateSpecValue(mutatedItem) : mutateSpecValue;
        mutatedItem[key] = mutatedResult;
      }
      mutatedItems.push(mutatedItem);
    }
    return mutatedItems;
  };
  return _mutate;
}

// ../../node_modules/@tidyjs/tidy/dist/es/total.js
function total(summarizeSpec, mutateSpec) {
  const _total = (items) => {
    const summarized = summarize(summarizeSpec)(items);
    const mutated = mutate(mutateSpec)(summarized);
    return [...items, ...mutated];
  };
  return _total;
}
function totalAll(summaryFn, mutateSpec) {
  const _totalAll = (items) => {
    const summarized = summarizeAll(summaryFn)(items);
    const mutated = mutate(mutateSpec)(summarized);
    return [...items, ...mutated];
  };
  return _totalAll;
}
function totalIf(predicateFn, summaryFn, mutateSpec) {
  const _totalIf = (items) => {
    const summarized = summarizeIf(predicateFn, summaryFn)(items);
    const mutated = mutate(mutateSpec)(summarized);
    return [...items, ...mutated];
  };
  return _totalIf;
}
function totalAt(keys, summaryFn, mutateSpec) {
  const _totalAt = (items) => {
    const summarized = summarizeAt(keys, summaryFn)(items);
    const mutated = mutate(mutateSpec)(summarized);
    return [...items, ...mutated];
  };
  return _totalAt;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/assignGroupKeys.js
function assignGroupKeys(d, keys) {
  if (d == null || typeof d !== "object" || Array.isArray(d))
    return d;
  const keysObj = Object.fromEntries(keys.filter((key) => typeof key[0] !== "function"));
  return Object.assign(keysObj, d);
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/groupTraversal.js
function groupTraversal(grouped, outputGrouped, keys, addSubgroup, addLeaves, level = 0) {
  for (const [key, value] of grouped.entries()) {
    const keysHere = [...keys, key];
    if (value instanceof Map) {
      const subgroup = addSubgroup(outputGrouped, keysHere, level);
      groupTraversal(value, subgroup, keysHere, addSubgroup, addLeaves, level + 1);
    } else {
      addLeaves(outputGrouped, keysHere, value, level);
    }
  }
  return outputGrouped;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/groupMap.js
function groupMap(grouped, groupFn, keyFn = (keys) => keys[keys.length - 1]) {
  function addSubgroup(parentGrouped, keys) {
    const subgroup = /* @__PURE__ */ new Map();
    parentGrouped.set(keyFn(keys), subgroup);
    return subgroup;
  }
  function addLeaves(parentGrouped, keys, values) {
    parentGrouped.set(keyFn(keys), groupFn(values, keys));
  }
  const outputGrouped = /* @__PURE__ */ new Map();
  groupTraversal(grouped, outputGrouped, [], addSubgroup, addLeaves);
  return outputGrouped;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/identity.js
var identity = (d) => d;

// ../../node_modules/@tidyjs/tidy/dist/es/groupBy.js
function groupBy(groupKeys, fns, options) {
  if (typeof fns === "function") {
    fns = [fns];
  } else if (arguments.length === 2 && fns != null && !Array.isArray(fns)) {
    options = fns;
  }
  const _groupBy = (items) => {
    const grouped = makeGrouped(items, groupKeys);
    const results = runFlow(grouped, fns, options == null ? void 0 : options.addGroupKeys);
    if (options == null ? void 0 : options.export) {
      switch (options.export) {
        case "grouped":
          return results;
        case "levels":
          return exportLevels(results, options);
        case "entries-obj":
        case "entriesObject":
          return exportLevels(results, {
            ...options,
            export: "levels",
            levels: ["entries-object"]
          });
        default:
          return exportLevels(results, {
            ...options,
            export: "levels",
            levels: [options.export]
          });
      }
    }
    const ungrouped = ungroup(results, options == null ? void 0 : options.addGroupKeys);
    return ungrouped;
  };
  return _groupBy;
}
groupBy.grouped = (options) => ({ ...options, export: "grouped" });
groupBy.entries = (options) => ({ ...options, export: "entries" });
groupBy.entriesObject = (options) => ({ ...options, export: "entries-object" });
groupBy.object = (options) => ({ ...options, export: "object" });
groupBy.map = (options) => ({ ...options, export: "map" });
groupBy.keys = (options) => ({ ...options, export: "keys" });
groupBy.values = (options) => ({ ...options, export: "values" });
groupBy.levels = (options) => ({ ...options, export: "levels" });
function runFlow(items, fns, addGroupKeys) {
  let result = items;
  if (!(fns == null ? void 0 : fns.length))
    return result;
  for (const fn of fns) {
    if (!fn)
      continue;
    result = groupMap(result, (items2, keys) => {
      const context = { groupKeys: keys };
      let leafItemsMapped = fn(items2, context);
      if (addGroupKeys !== false) {
        leafItemsMapped = leafItemsMapped.map((item) => assignGroupKeys(item, keys));
      }
      return leafItemsMapped;
    });
  }
  return result;
}
function makeGrouped(items, groupKeys) {
  const groupKeyFns = singleOrArray(groupKeys).map((key, i) => {
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    const keyCache = /* @__PURE__ */ new Map();
    return (d) => {
      const keyValue = keyFn(d);
      const keyValueOf = typeof keyValue === "object" ? keyValue.valueOf() : keyValue;
      if (keyCache.has(keyValueOf)) {
        return keyCache.get(keyValueOf);
      }
      const keyWithName = [key, keyValue];
      keyCache.set(keyValueOf, keyWithName);
      return keyWithName;
    };
  });
  const grouped = group(items, ...groupKeyFns);
  return grouped;
}
function ungroup(grouped, addGroupKeys) {
  const items = [];
  groupTraversal(grouped, items, [], identity, (root, keys, values) => {
    let valuesToAdd = values;
    if (addGroupKeys !== false) {
      valuesToAdd = values.map((d) => assignGroupKeys(d, keys));
    }
    root.push(...valuesToAdd);
  });
  return items;
}
var defaultCompositeKey = (keys) => keys.join("/");
function processFromGroupsOptions(options) {
  var _a;
  const {
    flat,
    single,
    mapLeaf = identity,
    mapLeaves = identity,
    addGroupKeys
  } = options;
  let compositeKey;
  if (options.flat) {
    compositeKey = (_a = options.compositeKey) != null ? _a : defaultCompositeKey;
  }
  const groupFn = (values, keys) => {
    return single ? mapLeaf(addGroupKeys === false ? values[0] : assignGroupKeys(values[0], keys)) : mapLeaves(values.map((d) => mapLeaf(addGroupKeys === false ? d : assignGroupKeys(d, keys))));
  };
  const keyFn = flat ? (keys) => compositeKey(keys.map((d) => d[1])) : (keys) => keys[keys.length - 1][1];
  return { groupFn, keyFn };
}
function exportLevels(grouped, options) {
  const { groupFn, keyFn } = processFromGroupsOptions(options);
  let { mapEntry = identity } = options;
  const { levels = ["entries"] } = options;
  const levelSpecs = [];
  for (const levelOption of levels) {
    switch (levelOption) {
      case "entries":
      case "entries-object":
      case "entries-obj":
      case "entriesObject": {
        const levelMapEntry = (levelOption === "entries-object" || levelOption === "entries-obj" || levelOption === "entriesObject") && options.mapEntry == null ? ([key, values]) => ({ key, values }) : mapEntry;
        levelSpecs.push({
          id: "entries",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup, key, level) => {
            parentGrouped.push(levelMapEntry([key, newSubgroup], level));
          },
          addLeaf: (parentGrouped, key, values, level) => {
            parentGrouped.push(levelMapEntry([key, values], level));
          }
        });
        break;
      }
      case "map":
        levelSpecs.push({
          id: "map",
          createEmptySubgroup: () => /* @__PURE__ */ new Map(),
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped.set(key, newSubgroup);
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped.set(key, values);
          }
        });
        break;
      case "object":
        levelSpecs.push({
          id: "object",
          createEmptySubgroup: () => ({}),
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped[key] = newSubgroup;
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped[key] = values;
          }
        });
        break;
      case "keys":
        levelSpecs.push({
          id: "keys",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped.push([key, newSubgroup]);
          },
          addLeaf: (parentGrouped, key) => {
            parentGrouped.push(key);
          }
        });
        break;
      case "values":
        levelSpecs.push({
          id: "values",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup) => {
            parentGrouped.push(newSubgroup);
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped.push(values);
          }
        });
        break;
      default: {
        if (typeof levelOption === "object") {
          levelSpecs.push(levelOption);
        }
      }
    }
  }
  const addSubgroup = (parentGrouped, keys, level) => {
    var _a, _b;
    if (options.flat) {
      return parentGrouped;
    }
    const levelSpec = (_a = levelSpecs[level]) != null ? _a : levelSpecs[levelSpecs.length - 1];
    const nextLevelSpec = (_b = levelSpecs[level + 1]) != null ? _b : levelSpec;
    const newSubgroup = nextLevelSpec.createEmptySubgroup();
    levelSpec.addSubgroup(parentGrouped, newSubgroup, keyFn(keys), level);
    return newSubgroup;
  };
  const addLeaf = (parentGrouped, keys, values, level) => {
    var _a;
    const levelSpec = (_a = levelSpecs[level]) != null ? _a : levelSpecs[levelSpecs.length - 1];
    levelSpec.addLeaf(parentGrouped, keyFn(keys), groupFn(values, keys), level);
  };
  const initialOutputObject = levelSpecs[0].createEmptySubgroup();
  return groupTraversal(grouped, initialOutputObject, [], addSubgroup, addLeaf);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/n.js
function n() {
  return (items) => items.length;
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/sum.js
function sum2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => fsum(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/tally.js
function tally(options) {
  const _tally = (items) => {
    const { name = "n", wt } = options != null ? options : {};
    const summarized = summarize({ [name]: wt == null ? n() : sum2(wt) })(items);
    return summarized;
  };
  return _tally;
}

// ../../node_modules/@tidyjs/tidy/dist/es/count.js
function count2(groupKeys, options) {
  const _count = (items) => {
    options = options != null ? options : {};
    const { name = "n", sort: sort2 } = options;
    const results = tidy(items, groupBy(groupKeys, [tally(options)]), sort2 ? arrange(desc(name)) : identity);
    return results;
  };
  return _count;
}

// ../../node_modules/@tidyjs/tidy/dist/es/rename.js
function rename(renameSpec) {
  const _rename = (items) => {
    return items.map((d) => {
      var _a;
      const mapped = {};
      const keys = Object.keys(d);
      for (const key of keys) {
        const newKey = (_a = renameSpec[key]) != null ? _a : key;
        mapped[newKey] = d[key];
      }
      return mapped;
    });
  };
  return _rename;
}

// ../../node_modules/@tidyjs/tidy/dist/es/slice.js
function slice2(start, end) {
  const _slice = (items) => items.slice(start, end);
  return _slice;
}
var sliceHead = (n2) => slice2(0, n2);
var sliceTail = (n2) => slice2(-n2);
function sliceMin(n2, orderBy) {
  const _sliceMin = (items) => arrange(orderBy)(items).slice(0, n2);
  return _sliceMin;
}
function sliceMax(n2, orderBy) {
  const _sliceMax = (items) => typeof orderBy === "function" ? arrange(orderBy)(items).slice(-n2).reverse() : arrange(desc(orderBy))(items).slice(0, n2);
  return _sliceMax;
}
function sliceSample(n2, options) {
  options = options != null ? options : {};
  const { replace } = options;
  const _sliceSample = (items) => {
    if (!items.length)
      return items.slice();
    if (replace) {
      const sliced = [];
      for (let i = 0; i < n2; ++i) {
        sliced.push(items[Math.floor(Math.random() * items.length)]);
      }
      return sliced;
    }
    return shuffle_default(items.slice()).slice(0, n2);
  };
  return _sliceSample;
}

// ../../node_modules/@tidyjs/tidy/dist/es/innerJoin.js
function autodetectByMap(itemsA, itemsB) {
  if (itemsA.length === 0 || itemsB.length === 0)
    return {};
  const keysA = Object.keys(itemsA[0]);
  const keysB = Object.keys(itemsB[0]);
  const byMap = {};
  for (const key of keysA) {
    if (keysB.includes(key)) {
      byMap[key] = key;
    }
  }
  return byMap;
}
function makeByMap(by) {
  if (Array.isArray(by)) {
    const byMap = {};
    for (const key of by) {
      byMap[key] = key;
    }
    return byMap;
  } else if (typeof by === "object") {
    return by;
  }
  return { [by]: by };
}
function isMatch(d, j, byMap) {
  for (const jKey in byMap) {
    const dKey = byMap[jKey];
    if (d[dKey] !== j[jKey]) {
      return false;
    }
  }
  return true;
}
function innerJoin(itemsToJoin, options) {
  const _innerJoin = (items) => {
    const byMap = (options == null ? void 0 : options.by) == null ? autodetectByMap(items, itemsToJoin) : makeByMap(options.by);
    const joined = items.flatMap((d) => {
      const matches2 = itemsToJoin.filter((j) => isMatch(d, j, byMap));
      return matches2.map((j) => ({ ...d, ...j }));
    });
    return joined;
  };
  return _innerJoin;
}

// ../../node_modules/@tidyjs/tidy/dist/es/leftJoin.js
function leftJoin(itemsToJoin, options) {
  const _leftJoin = (items) => {
    if (!itemsToJoin.length)
      return items;
    const byMap = (options == null ? void 0 : options.by) == null ? autodetectByMap(items, itemsToJoin) : makeByMap(options.by);
    const joinObjectKeys = Object.keys(itemsToJoin[0]);
    const joined = items.flatMap((d) => {
      const matches2 = itemsToJoin.filter((j) => isMatch(d, j, byMap));
      if (matches2.length) {
        return matches2.map((j) => ({ ...d, ...j }));
      }
      const undefinedFill = Object.fromEntries(joinObjectKeys.filter((key) => d[key] == null).map((key) => [key, void 0]));
      return { ...d, ...undefinedFill };
    });
    return joined;
  };
  return _leftJoin;
}

// ../../node_modules/@tidyjs/tidy/dist/es/fullJoin.js
function fullJoin(itemsToJoin, options) {
  const _fullJoin = (items) => {
    if (!itemsToJoin.length)
      return items;
    if (!items.length)
      return itemsToJoin;
    const byMap = (options == null ? void 0 : options.by) == null ? autodetectByMap(items, itemsToJoin) : makeByMap(options.by);
    const matchMap = /* @__PURE__ */ new Map();
    const joinObjectKeys = Object.keys(itemsToJoin[0]);
    const joined = items.flatMap((d) => {
      const matches2 = itemsToJoin.filter((j) => {
        const matched = isMatch(d, j, byMap);
        if (matched) {
          matchMap.set(j, true);
        }
        return matched;
      });
      if (matches2.length) {
        return matches2.map((j) => ({ ...d, ...j }));
      }
      const undefinedFill = Object.fromEntries(joinObjectKeys.filter((key) => d[key] == null).map((key) => [key, void 0]));
      return { ...d, ...undefinedFill };
    });
    if (matchMap.size < itemsToJoin.length) {
      const leftEmptyObject = Object.fromEntries(Object.keys(items[0]).map((key) => [key, void 0]));
      for (const item of itemsToJoin) {
        if (!matchMap.has(item)) {
          joined.push({ ...leftEmptyObject, ...item });
        }
      }
    }
    return joined;
  };
  return _fullJoin;
}

// ../../node_modules/@tidyjs/tidy/dist/es/mutateWithSummary.js
function mutateWithSummary(mutateSpec) {
  const _mutate = (items) => {
    const mutatedItems = items.map((d) => ({ ...d }));
    for (const key in mutateSpec) {
      const mutateSpecValue = mutateSpec[key];
      const mutatedResult = typeof mutateSpecValue === "function" ? mutateSpecValue(mutatedItems) : mutateSpecValue;
      const mutatedVector = (mutatedResult == null ? void 0 : mutatedResult[Symbol.iterator]) && typeof mutatedResult !== "string" ? mutatedResult : items.map(() => mutatedResult);
      let i = -1;
      for (const mutatedItem of mutatedItems) {
        mutatedItem[key] = mutatedVector[++i];
      }
    }
    return mutatedItems;
  };
  return _mutate;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/keysFromItems.js
function keysFromItems(items) {
  if (items.length < 1)
    return [];
  const keys = Object.keys(items[0]);
  return keys;
}

// ../../node_modules/@tidyjs/tidy/dist/es/selectors/everything.js
function everything() {
  return (items) => {
    const keys = keysFromItems(items);
    return keys;
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/select.js
function processSelectors(items, selectKeys) {
  let processedSelectKeys = [];
  for (const keyInput of singleOrArray(selectKeys)) {
    if (typeof keyInput === "function") {
      processedSelectKeys.push(...keyInput(items));
    } else {
      processedSelectKeys.push(keyInput);
    }
  }
  if (processedSelectKeys.length && processedSelectKeys[0][0] === "-") {
    processedSelectKeys = [...everything()(items), ...processedSelectKeys];
  }
  const negationMap = {};
  const keysWithoutNegations = [];
  for (let k = processedSelectKeys.length - 1; k >= 0; k--) {
    const key = processedSelectKeys[k];
    if (key[0] === "-") {
      negationMap[key.substring(1)] = true;
      continue;
    }
    if (negationMap[key]) {
      negationMap[key] = false;
      continue;
    }
    keysWithoutNegations.unshift(key);
  }
  processedSelectKeys = Array.from(new Set(keysWithoutNegations));
  return processedSelectKeys;
}
function select(selectKeys) {
  const _select = (items) => {
    let processedSelectKeys = processSelectors(items, selectKeys);
    if (!processedSelectKeys.length)
      return items;
    return items.map((d) => {
      const mapped = {};
      for (const key of processedSelectKeys) {
        mapped[key] = d[key];
      }
      return mapped;
    });
  };
  return _select;
}

// ../../node_modules/@tidyjs/tidy/dist/es/transmute.js
function transmute(mutateSpec) {
  const _transmute = (items) => {
    const mutated = mutate(mutateSpec)(items);
    const picked = select(Object.keys(mutateSpec))(mutated);
    return picked;
  };
  return _transmute;
}

// ../../node_modules/@tidyjs/tidy/dist/es/addRows.js
function addRows(itemsToAdd) {
  const _addRows = (items) => {
    if (typeof itemsToAdd === "function") {
      return [...items, ...singleOrArray(itemsToAdd(items))];
    }
    return [...items, ...singleOrArray(itemsToAdd)];
  };
  return _addRows;
}

// ../../node_modules/@tidyjs/tidy/dist/es/pivotWider.js
function pivotWider(options) {
  const _pivotWider = (items) => {
    const {
      namesFrom,
      valuesFrom,
      valuesFill,
      valuesFillMap,
      namesSep = "_"
    } = options;
    const namesFromKeys = Array.isArray(namesFrom) ? namesFrom : [namesFrom];
    const valuesFromKeys = Array.isArray(valuesFrom) ? valuesFrom : [valuesFrom];
    const wider = [];
    if (!items.length)
      return wider;
    const idColumns = Object.keys(items[0]).filter((key) => !namesFromKeys.includes(key) && !valuesFromKeys.includes(key));
    const nameValuesMap = {};
    for (const item of items) {
      for (const nameKey of namesFromKeys) {
        if (nameValuesMap[nameKey] == null) {
          nameValuesMap[nameKey] = {};
        }
        nameValuesMap[nameKey][item[nameKey]] = true;
      }
    }
    const nameValuesLists = [];
    for (const nameKey in nameValuesMap) {
      nameValuesLists.push(Object.keys(nameValuesMap[nameKey]));
    }
    const baseWideObj = {};
    const combos = makeCombinations(namesSep, nameValuesLists);
    for (const nameKey of combos) {
      if (valuesFromKeys.length === 1) {
        baseWideObj[nameKey] = valuesFillMap != null ? valuesFillMap[valuesFromKeys[0]] : valuesFill;
        continue;
      }
      for (const valueKey of valuesFromKeys) {
        baseWideObj[`${valueKey}${namesSep}${nameKey}`] = valuesFillMap != null ? valuesFillMap[valueKey] : valuesFill;
      }
    }
    function widenItems(items2) {
      if (!items2.length)
        return [];
      const wide = { ...baseWideObj };
      for (const idKey of idColumns) {
        wide[idKey] = items2[0][idKey];
      }
      for (const item of items2) {
        const nameKey = namesFromKeys.map((key) => item[key]).join(namesSep);
        if (valuesFromKeys.length === 1) {
          wide[nameKey] = item[valuesFromKeys[0]];
          continue;
        }
        for (const valueKey of valuesFromKeys) {
          wide[`${valueKey}${namesSep}${nameKey}`] = item[valueKey];
        }
      }
      return [wide];
    }
    if (!idColumns.length) {
      return widenItems(items);
    }
    const finish = tidy(items, groupBy(idColumns, [widenItems]));
    return finish;
  };
  return _pivotWider;
}
function makeCombinations(separator = "_", arrays) {
  function combine(accum, prefix, remainingArrays) {
    if (!remainingArrays.length && prefix != null) {
      accum.push(prefix);
      return;
    }
    const array2 = remainingArrays[0];
    const newRemainingArrays = remainingArrays.slice(1);
    for (const item of array2) {
      combine(accum, prefix == null ? item : `${prefix}${separator}${item}`, newRemainingArrays);
    }
  }
  const result = [];
  combine(result, null, arrays);
  return result;
}

// ../../node_modules/@tidyjs/tidy/dist/es/pivotLonger.js
function pivotLonger(options) {
  const _pivotLonger = (items) => {
    var _a;
    const { namesTo, valuesTo, namesSep = "_" } = options;
    const cols = (_a = options.cols) != null ? _a : [];
    const colsKeys = processSelectors(items, cols);
    const namesToKeys = Array.isArray(namesTo) ? namesTo : [namesTo];
    const valuesToKeys = Array.isArray(valuesTo) ? valuesTo : [valuesTo];
    const hasMultipleNamesTo = namesToKeys.length > 1;
    const hasMultipleValuesTo = valuesToKeys.length > 1;
    const longer = [];
    for (const item of items) {
      const remainingKeys = Object.keys(item).filter((key) => !colsKeys.includes(key));
      const baseObj = {};
      for (const key of remainingKeys) {
        baseObj[key] = item[key];
      }
      const nameValueKeysWithoutValuePrefix = hasMultipleValuesTo ? Array.from(new Set(colsKeys.map((key) => key.substring(key.indexOf(namesSep) + 1)))) : colsKeys;
      for (const nameValue of nameValueKeysWithoutValuePrefix) {
        const entryObj = { ...baseObj };
        for (const valueKey of valuesToKeys) {
          const itemKey = hasMultipleValuesTo ? `${valueKey}${namesSep}${nameValue}` : nameValue;
          const nameValueParts = hasMultipleNamesTo ? nameValue.split(namesSep) : [nameValue];
          let i = 0;
          for (const nameKey of namesToKeys) {
            const nameValuePart = nameValueParts[i++];
            entryObj[nameKey] = nameValuePart;
            entryObj[valueKey] = item[itemKey];
          }
        }
        longer.push(entryObj);
      }
    }
    return longer;
  };
  return _pivotLonger;
}

// ../../node_modules/@tidyjs/tidy/dist/es/expand.js
function expand(expandKeys) {
  const _expand = (items) => {
    const keyMap = makeKeyMap(expandKeys);
    const vectors = [];
    for (const key in keyMap) {
      const keyValue = keyMap[key];
      let values;
      if (typeof keyValue === "function") {
        values = keyValue(items);
      } else if (Array.isArray(keyValue)) {
        values = keyValue;
      } else {
        values = Array.from(new Set(items.map((d) => d[key])));
      }
      vectors.push(values.map((value) => ({ [key]: value })));
    }
    return makeCombinations2(vectors);
  };
  return _expand;
}
function makeCombinations2(vectors) {
  function combine(accum, baseObj, remainingVectors) {
    if (!remainingVectors.length && baseObj != null) {
      accum.push(baseObj);
      return;
    }
    const vector = remainingVectors[0];
    const newRemainingArrays = remainingVectors.slice(1);
    for (const item of vector) {
      combine(accum, { ...baseObj, ...item }, newRemainingArrays);
    }
  }
  const result = [];
  combine(result, null, vectors);
  return result;
}
function makeKeyMap(keys) {
  if (Array.isArray(keys)) {
    const keyMap = {};
    for (const key of keys) {
      keyMap[key] = key;
    }
    return keyMap;
  } else if (typeof keys === "object") {
    return keys;
  }
  return { [keys]: keys };
}

// ../../node_modules/@tidyjs/tidy/dist/es/sequences/fullSeq.js
function vectorSeq(values, period = 1) {
  let [min3, max3] = extent_default(values);
  const sequence = [];
  let value = min3;
  while (value <= max3) {
    sequence.push(value);
    value += period;
  }
  return sequence;
}
function vectorSeqDate(values, granularity = "day", period = 1) {
  let [min3, max3] = extent_default(values);
  const sequence = [];
  let value = new Date(min3);
  while (value <= max3) {
    sequence.push(new Date(value));
    if (granularity === "second" || granularity === "s" || granularity === "seconds") {
      value.setUTCSeconds(value.getUTCSeconds() + 1 * period);
    } else if (granularity === "minute" || granularity === "min" || granularity === "minutes") {
      value.setUTCMinutes(value.getUTCMinutes() + 1 * period);
    } else if (granularity === "day" || granularity === "d" || granularity === "days") {
      value.setUTCDate(value.getUTCDate() + 1 * period);
    } else if (granularity === "week" || granularity === "w" || granularity === "weeks") {
      value.setUTCDate(value.getUTCDate() + 7 * period);
    } else if (granularity === "month" || granularity === "m" || granularity === "months") {
      value.setUTCMonth(value.getUTCMonth() + 1 * period);
    } else if (granularity === "year" || granularity === "y" || granularity === "years") {
      value.setUTCFullYear(value.getUTCFullYear() + 1 * period);
    } else {
      throw new Error("Invalid granularity for date sequence: " + granularity);
    }
  }
  return sequence;
}
function fullSeq(key, period) {
  return function fullSeqInner(items) {
    period = period != null ? period : 1;
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    return vectorSeq(items.map(keyFn), period);
  };
}
function fullSeqDate(key, granularity, period) {
  return function fullSeqDateInner(items) {
    granularity = granularity != null ? granularity : "day";
    period = period != null ? period : 1;
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    return vectorSeqDate(items.map(keyFn), granularity, period);
  };
}
function fullSeqDateISOString(key, granularity, period) {
  return function fullSeqDateISOStringInner(items) {
    granularity = granularity != null ? granularity : "day";
    period = period != null ? period : 1;
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    return vectorSeqDate(items.map((d) => new Date(keyFn(d))), granularity, period).map((date) => date.toISOString());
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/replaceNully.js
function replaceNully(replaceSpec) {
  const _replaceNully = (items) => {
    const replacedItems = [];
    for (const d of items) {
      const obj = { ...d };
      for (const key in replaceSpec) {
        if (obj[key] == null) {
          obj[key] = replaceSpec[key];
        }
      }
      replacedItems.push(obj);
    }
    return replacedItems;
  };
  return _replaceNully;
}

// ../../node_modules/@tidyjs/tidy/dist/es/complete.js
function complete(expandKeys, replaceNullySpec) {
  const _complete = (items) => {
    const expanded = expand(expandKeys)(items);
    const joined = leftJoin(items)(expanded);
    return replaceNullySpec ? replaceNully(replaceNullySpec)(joined) : joined;
  };
  return _complete;
}

// ../../node_modules/@tidyjs/tidy/dist/es/fill.js
function fill(keys) {
  const _fill = (items) => {
    const keysArray = singleOrArray(keys);
    const replaceMap = {};
    return items.map((d) => {
      const obj = { ...d };
      for (const key of keysArray) {
        if (obj[key] != null) {
          replaceMap[key] = obj[key];
        } else if (replaceMap[key] != null) {
          obj[key] = replaceMap[key];
        }
      }
      return obj;
    });
  };
  return _fill;
}

// ../../node_modules/@tidyjs/tidy/dist/es/debug.js
function debug(label, options) {
  const _debug = (items, context) => {
    var _a;
    let prefix = "[tidy.debug";
    if ((_a = context == null ? void 0 : context.groupKeys) == null ? void 0 : _a.length) {
      const groupKeys = context.groupKeys;
      const groupKeyStrings = groupKeys.map((keyPair) => keyPair.join(": ")).join(", ");
      if (groupKeyStrings.length) {
        prefix += "|" + groupKeyStrings;
      }
    }
    options = options != null ? options : {};
    const { limit = 10, output = "table" } = options;
    const dashString = "--------------------------------------------------------------------------------";
    let numDashes = dashString.length;
    const prefixedLabel = prefix + "]" + (label == null ? "" : " " + label);
    numDashes = Math.max(0, numDashes - (prefixedLabel.length + 2));
    console.log(`${prefixedLabel} ${dashString.substring(0, numDashes)}`);
    console[output](limit == null || limit >= items.length ? items : items.slice(0, limit));
    return items;
  };
  return _debug;
}

// ../../node_modules/@tidyjs/tidy/dist/es/math/math.js
var math_exports = {};
__export(math_exports, {
  add: () => add,
  rate: () => rate,
  subtract: () => subtract
});
function rate(numerator, denominator, allowDivideByZero) {
  return numerator == null || denominator == null ? void 0 : denominator === 0 && numerator === 0 ? 0 : !allowDivideByZero && denominator === 0 ? void 0 : numerator / denominator;
}
function subtract(a, b, nullyZero) {
  return a == null || b == null ? nullyZero ? (a != null ? a : 0) - (b != null ? b : 0) : void 0 : a - b;
}
function add(a, b, nullyZero) {
  return a == null || b == null ? nullyZero ? (a != null ? a : 0) + (b != null ? b : 0) : void 0 : a + b;
}

// ../../node_modules/@tidyjs/tidy/dist/es/item/rate.js
function rate2(numerator, denominator, options) {
  const numeratorFn = typeof numerator === "function" ? numerator : (d) => d[numerator];
  const denominatorFn = typeof denominator === "function" ? denominator : (d) => d[denominator];
  const { predicate, allowDivideByZero } = options != null ? options : {};
  return predicate == null ? (d) => {
    const denom = denominatorFn(d);
    const numer = numeratorFn(d);
    return rate(numer, denom, allowDivideByZero);
  } : (d) => {
    if (!predicate(d))
      return void 0;
    const denom = denominatorFn(d);
    const numer = numeratorFn(d);
    return rate(numer, denom, allowDivideByZero);
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/summation.js
function fcumsum2(items, accessor) {
  let sum3 = new Adder(), i = 0;
  return Float64Array.from(items, (value) => sum3.add(+(accessor(value, i++, items) || 0)));
}
function mean2(items, accessor) {
  let n2 = 0;
  for (let i = 0; i < items.length; ++i) {
    const value = accessor(items[i], i, items);
    if (+value === value) {
      n2 += 1;
    }
  }
  return n2 ? fsum(items, accessor) / n2 : void 0;
}

// ../../node_modules/@tidyjs/tidy/dist/es/vector/cumsum.js
function cumsum2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => fcumsum2(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/vector/roll.js
function roll(width, rollFn, options) {
  const { partial = false } = options != null ? options : {};
  return (items) => {
    return items.map((_, i) => {
      const endIndex = i;
      if (!partial && endIndex - width + 1 < 0) {
        return void 0;
      }
      const startIndex = Math.max(0, endIndex - width + 1);
      const itemsInWindow = items.slice(startIndex, endIndex + 1);
      return rollFn(itemsInWindow, endIndex);
    });
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/vector/lag.js
function lag(key, options) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  const { n: n2 = 1, default: defaultValue } = options != null ? options : {};
  return (items) => {
    return items.map((_, i) => {
      const lagItem = items[i - n2];
      return lagItem == null ? defaultValue : keyFn(lagItem);
    });
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/vector/lead.js
function lead(key, options) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  const { n: n2 = 1, default: defaultValue } = options != null ? options : {};
  return (items) => {
    return items.map((_, i) => {
      const leadItem = items[i + n2];
      return leadItem == null ? defaultValue : keyFn(leadItem);
    });
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/min.js
function min2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => min(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/max.js
function max2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => max(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/mean.js
function mean3(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => mean2(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/meanRate.js
function meanRate(numerator, denominator) {
  const numeratorFn = typeof numerator === "function" ? numerator : (d) => d[numerator];
  const denominatorFn = typeof denominator === "function" ? denominator : (d) => d[denominator];
  return (items) => {
    const numerator2 = fsum(items, numeratorFn);
    const denominator2 = fsum(items, denominatorFn);
    return rate(numerator2, denominator2);
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/median.js
function median(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => median_default(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/deviation.js
function deviation2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => deviation(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/variance.js
function variance2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => variance(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/nDistinct.js
function nDistinct(key, options = {}) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => {
    const uniques = /* @__PURE__ */ new Map();
    let count3 = 0;
    for (const item of items) {
      const value = keyFn(item);
      if (!uniques.has(value)) {
        if (!options.includeUndefined && value === void 0 || options.includeNull === false && value === null) {
          continue;
        }
        count3 += 1;
        uniques.set(value, true);
      }
    }
    return count3;
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/first.js
function first(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => items.length ? keyFn(items[0]) : void 0;
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/last.js
function last(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => items.length ? keyFn(items[items.length - 1]) : void 0;
}

// ../../node_modules/@tidyjs/tidy/dist/es/selectors/startsWith.js
function startsWith(prefix, ignoreCase = true) {
  return (items) => {
    const regex = new RegExp(`^${prefix}`, ignoreCase ? "i" : void 0);
    const keys = keysFromItems(items);
    return keys.filter((d) => regex.test(d));
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/selectors/endsWith.js
function endsWith(suffix, ignoreCase = true) {
  return (items) => {
    const regex = new RegExp(`${suffix}$`, ignoreCase ? "i" : void 0);
    const keys = keysFromItems(items);
    return keys.filter((d) => regex.test(d));
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/selectors/contains.js
function contains(substring, ignoreCase = true) {
  return (items) => {
    const regex = new RegExp(substring, ignoreCase ? "i" : void 0);
    const keys = keysFromItems(items);
    return keys.filter((d) => regex.test(d));
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/selectors/matches.js
function matches(regex) {
  return (items) => {
    const keys = keysFromItems(items);
    return keys.filter((d) => regex.test(d));
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/selectors/numRange.js
function numRange(prefix, range, width) {
  return (items) => {
    const keys = keysFromItems(items);
    const matchKeys = [];
    for (let i = range[0]; i <= range[1]; ++i) {
      const num = width == null ? i : new String("00000000" + i).slice(-width);
      matchKeys.push(`${prefix}${num}`);
    }
    return keys.filter((d) => matchKeys.includes(d));
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/selectors/negate.js
function negate(selectors) {
  return (items) => {
    let keySet = /* @__PURE__ */ new Set();
    for (const selector of singleOrArray(selectors)) {
      if (typeof selector === "function") {
        const keys2 = selector(items);
        for (const key of keys2) {
          keySet.add(key);
        }
      } else {
        keySet.add(selector);
      }
    }
    const keys = Array.from(keySet).map((key) => `-${key}`);
    return keys;
  };
}
export {
  math_exports as TMath,
  addRows as addItems,
  addRows,
  arrange,
  asc,
  complete,
  contains,
  count2 as count,
  cumsum2 as cumsum,
  debug,
  desc,
  deviation2 as deviation,
  distinct,
  endsWith,
  everything,
  expand,
  fill,
  filter,
  first,
  fixedOrder,
  fullJoin,
  fullSeq,
  fullSeqDate,
  fullSeqDateISOString,
  groupBy,
  innerJoin,
  lag,
  last,
  lead,
  leftJoin,
  map,
  matches,
  max2 as max,
  mean3 as mean,
  meanRate,
  median,
  min2 as min,
  mutate,
  mutateWithSummary,
  n,
  nDistinct,
  negate,
  numRange,
  select as pick,
  pivotLonger,
  pivotWider,
  rate2 as rate,
  rename,
  replaceNully,
  roll,
  select,
  slice2 as slice,
  sliceHead,
  sliceMax,
  sliceMin,
  sliceSample,
  sliceTail,
  arrange as sort,
  startsWith,
  sum2 as sum,
  summarize,
  summarizeAll,
  summarizeAt,
  summarizeIf,
  tally,
  tidy,
  total,
  totalAll,
  totalAt,
  totalIf,
  transmute,
  variance2 as variance,
  vectorSeq,
  vectorSeqDate,
  when
};
//# sourceMappingURL=@tidyjs_tidy.js.map
