<script>
    import {writable} from 'svelte/store'
    import {setContext} from 'svelte'
    import { propKey, configKey } from './context'

    let props = writable({})
    let config = writable({})

    $: setContext(propKey, props)
    $: setContext(configKey, config)

    import ECharts from "./ECharts.svelte";
    import getColumnSummary from '../modules/getColumnSummary';
    import getDistinctValues from '../modules/getDistinctValues';
    import getStackPercentages from '../modules/getStackPercentages.js';
    import getSortedData from '../modules/getSortedData.js';
    import { standardizeDateColumn } from '../modules/dateParsing.js';
    import { formatAxisValue } from '../modules/formatting';
    import formatTitle from '../modules/formatTitle.js';
    import { formatValue } from '../modules/formatting.js';
    import ErrorChart from './ErrorChart.svelte';
    import checkInputs from '../modules/checkInputs';
    import {colours} from '../modules/colours'

// ---------------------------------------------------------------------------------------
// Input Props
// ---------------------------------------------------------------------------------------
    // Data and columns:
    export let data = undefined;
    export let x = undefined;
    export let y = undefined;
    export let series = undefined;
    export let size = undefined;
    export let tooltipTitle = undefined;

    // This should be reworked to fit better with svelte's reactivity. 

    // We rewrite the x and y values with fallbacks if they aren't present
    // the fallback logic *depends* on the values of x and y 
    // when x and y are replaced by the fallbacks, the fallback logic doesn't reset. 
    // if the y value isn't set, var y gets populated with a fall back from the data. 
    // if the data changes, we are now acting as if the fallback from above was entered by the user, and 
    // then we throw if the fallback column is now missing. 

    // This is a hack to get around the above
    const ySet = y ? true : false 
    const xSet = x ? true : false 

    export let swapXY = false; // Flipped axis chart
    $: if(swapXY === "true" || swapXY === true){
        swapXY = true;
    } else {
        swapXY = false;
    }

    // Chart titles:
    export let title = undefined;
    export let subtitle = undefined;

    // Chart type:
    export let chartType = "Chart"; // Used to label chart error messages
    export let bubble = false;
    export let hist = false;
    let reqCols;

    // X axis:
    export let xType = undefined; // category or value
    export let xAxisTitle = 'false'; // Default false. If true, use formatTitle(x). Or you can supply a custom string
    export let xBaseline = true;
    xBaseline = (xBaseline === "true" || xBaseline === true);
    export let xTickMarks = false;
    xTickMarks = (xTickMarks === "true" || xTickMarks === true);
    export let xGridlines = false;
    xGridlines = (xGridlines === "true" || xGridlines === true);
    export let xAxisLabels = true;
    xAxisLabels = (xAxisLabels === "true" || xAxisLabels === true);
    export let sort = false; // sorts x values in case x is out of order in dataset (e.g., would create line chart that is out of order)
    sort = (sort === "true" || sort === true);

    // Y axis:
    export let yAxisTitle = 'false'; // Default false. If true, use formatTitle(x). Or you can supply a custom string
    export let yBaseline = false;
    yBaseline = (yBaseline === "true" || yBaseline === true);
    export let yTickMarks = false;
    yTickMarks = (yTickMarks === "true" || yTickMarks === true);
    export let yGridlines = true;
    yGridlines = (yGridlines === "true" || yGridlines === true);
    export let yAxisLabels = true;
    yAxisLabels = (yAxisLabels === "true" || yAxisLabels === true);
    export let yMin = undefined;
    export let yMax = undefined;

    // Legend:
    export let legend = undefined;

    // Additional Config Options:
    export let options = undefined; // additional ECharts config object that will append to the config generated by our API

    export let stacked100 = false;

// ---------------------------------------------------------------------------------------
// Variable Declaration
// ---------------------------------------------------------------------------------------
    // Column Summary:
    let columnSummary;
    let columnNames;
    let uColNames = [];
    let unusedColumns = [];
    let uColType;
    let uColName;
    let xDataType;
    let xMismatch;
    let xFormat;
    let yFormat;
    let sizeFormat;
    let xUnitSummary;
    let yUnitSummary;       
    let xDistinct;

    // Individual Config Sections:
    let horizAxisConfig;
    let verticalAxisConfig;
    let horizAxisTitleConfig;      
    let chartConfig;

    // Chart area sizing:
    let chartAreaHeight;
    let hasTitle;
    let hasSubtitle;
    let hasLegend;
    let hasTopAxisTitle;
    let hasBottomAxisTitle;
    let titleFontSize;
    let subtitleFontSize;
    let titleBoxPadding;
    let titleBoxHeight;
    let chartAreaPaddingTop;
    let chartAreaPaddingBottom;
    let bottomAxisTitleSize;
    let topAxisTitleSize; 
    let legendHeight;
    let legendPaddingTop;
    let legendTop;
    let chartTop;
    let chartBottom;
    let chartContainerHeight;
    let topAxisTitleTop;

    let horizAxisTitle;

    // Adjustment to avoid small bars on horizontal bar chart (extend chart height to accomodate):
    let maxBars;
    let barCount;
    let heightMultiplier;

    // Set final chart height:
    let height;
    let width;


    let missingCols = [];

    let originalRun = true;

    // Error Handling:

    let inputCols = [];
    let optCols = [];
    let i;

    let error;

    // Date String Handling:
    let columnSummaryArray;
    let dateCols;

$: {
    try{
    error = undefined
    missingCols = [];
    unusedColumns = []
    // Error Handling:
    inputCols = []
    optCols = [];
    uColName = []
    
    checkInputs(data); // check that dataset exists

    // ---------------------------------------------------------------------------------------
    // Get column information
    // ---------------------------------------------------------------------------------------
        // Get column summary:
        columnSummary = getColumnSummary(data);

        // Get column names:
        columnNames = Object.keys(columnSummary)

    // ---------------------------------------------------------------------------------------
    // Make assumptions to complete required props
    // ---------------------------------------------------------------------------------------
    // If no x column was supplied, assume first column in dataset is x
        if(!xSet){
            x = columnNames[0]
        }

        // If no y column(s) supplied, assume all number columns other than x are the y columns:
        if(!ySet) {
            uColNames = columnNames.filter(function(col){
                return ![x, series, size].includes(col)
            });

            for(let i = 0; i < uColNames.length; i++){
                uColName = uColNames[i]
                uColType = columnSummary[uColName].type
                if(uColType === "number"){
                    unusedColumns.push(uColName)
                }
            }

            y = unusedColumns.length > 1 ? unusedColumns : unusedColumns[0];
        }
        // Establish required columns based on chart type:
        if(bubble){
            reqCols = {
                "x": x,
                "y": y,
                "size": size
            }
        } else if(hist){
            reqCols = {
                "x": x
            }
        } else {
            reqCols = {
                "x": x,
                "y": y
            }
        }

        // Check which columns were not supplied to the chart:
        for(let property in reqCols){
            if(reqCols[property] == null){
                missingCols.push(property)
            }
        }
        
        if(missingCols.length === 1) { 
            throw Error(new Intl.ListFormat().format(missingCols) + " is required");
        } else if(missingCols.length > 1){
            throw Error(new Intl.ListFormat().format(missingCols) + " are required");
        }

        // Fix for stacked100 overwriting y variable. Bandaid fix - not a long-term solution:
        if(stacked100 === true && y.includes("_pct") && originalRun === false){
            if(typeof y === 'object'){
                for(let i=0; i<y.length; i++){
                    y[i] = y[i].replace("_pct", "")
                }
                originalRun = false;
            } else {
                y = y.replace("_pct", "")
                originalRun = false;
            }
        }

        // Check the inputs supplied to the chart:
        if(x){inputCols.push(x)};
        if(y){
            if(typeof y === 'object'){
                for(i=0; i < y.length; i++){
                    inputCols.push(y[i])
                }
            } else {
                inputCols.push(y)
            }
        };
        if(size){inputCols.push(size)};
        if(series){optCols.push(series)};
        if(tooltipTitle){optCols.push(tooltipTitle)}

        checkInputs(data, inputCols, optCols)

    // ---------------------------------------------------------------------------------------
    // Aggregate Data if Required
    // ---------------------------------------------------------------------------------------

        if(stacked100 === true){
            data = getStackPercentages(data, x, y);

            if(typeof y === 'object'){
                for(let i=0; i<y.length; i++){
                    y[i] = y[i] + '_pct'
                }
                originalRun = false;
            } else {
                y = y + '_pct'
                originalRun = false;
            }

            // Re-run column summary for new columns (not ideal):
            columnSummary = getColumnSummary(data);
        }

    // ---------------------------------------------------------------------------------------
    // Define x axis type
    // ---------------------------------------------------------------------------------------
        xDataType = columnSummary[x].type;

        // Get xDataType into ECharts default types:
        switch (xDataType) {
            case "number":
                xDataType = "value";
                break;
            case "string":
                xDataType = "category";
                break;
            case "date":
                xDataType = "time";
                break;
            default:
                break;
        }

        xType = xType === "category" ? "category" : xDataType;

        // Throw error if attempting to plot value or time on horizontal x-axis:
        if(swapXY && xType !== "category"){
            throw Error("Horizontal charts do not support a value or time-based x-axis. You can either change your SQL query to output string values or set swapXY=false.")
        }

        // Override xType if axes are swapped - only category enabled on horizontal axis
        if(swapXY){xType = "category"}

        // Check for x mismatch:
        xMismatch = (xDataType === "value" && xType === "category");



    // ---------------------------------------------------------------------------------------
    // Sort data based on xType
    // ---------------------------------------------------------------------------------------
        data = sort ? 
            (xDataType === "category") ? 
                getSortedData(data, y, false) 
                : getSortedData(data, x, true) 
            : data;

        // Always sort time axes by x - this prevents the lines from being drawn out of order
        if(xDataType === "time"){
            data = getSortedData(data, x, true);
        }
    
    // ---------------------------------------------------------------------------------------
    // Standardize date columns
    // ---------------------------------------------------------------------------------------

    columnSummaryArray = getColumnSummary(data, "array");
    dateCols = columnSummaryArray.filter(d => d.type === "date")
    dateCols = dateCols.map(d => d.id);

    if(dateCols.length > 0){
        for(let i = 0; i < dateCols.length; i++){
            data = standardizeDateColumn(data, dateCols[i]);
        }
    }
            
    // ---------------------------------------------------------------------------------------
    // Get format codes for axes
    // ---------------------------------------------------------------------------------------
        xFormat = columnSummary[x].format;
        if(!y){yFormat = "str"} else {
            if(typeof y === 'object'){
                yFormat = columnSummary[y[0]].format;
            } else {
                yFormat = columnSummary[y].format;
            }
        }

        if(size){
            sizeFormat = columnSummary[size].format;
        }

        xUnitSummary = columnSummary[x].columnUnitSummary;
        
        if (y) {
            if(typeof y === 'object'){
                yUnitSummary = columnSummary[y[0]].columnUnitSummary;
            } else {
                yUnitSummary = columnSummary[y].columnUnitSummary;
            }
        }

        xAxisTitle = xAxisTitle === 'true' ? formatTitle(x, xFormat) : xAxisTitle === 'false' ? '' : xAxisTitle;
        yAxisTitle = yAxisTitle === 'true' ? typeof y === 'object' ? '' : formatTitle(y, yFormat) : yAxisTitle === 'false' ? '' : yAxisTitle;

    // ---------------------------------------------------------------------------------------
    // Set legend flag
    // ---------------------------------------------------------------------------------------
        if(legend !== undefined){
            legend = (legend === "true" || legend === true)
        }

        legend = legend ?? (series != undefined || typeof y === "object")

    // ---------------------------------------------------------------------------------------
    // Add props to store to let child components access them
    // ---------------------------------------------------------------------------------------
        props.update(d => {return {...d, data, x, y, series, swapXY, sort, xType, xFormat, yFormat, sizeFormat, xMismatch, size, yMin, columnSummary, xAxisTitle, yAxisTitle, tooltipTitle}});

    // ---------------------------------------------------------------------------------------
    // Axis Configuration
    // ---------------------------------------------------------------------------------------
        xDistinct = getDistinctValues(data, x);

        if(swapXY){
            horizAxisConfig = {
                type: "value",
                position: "top",
                axisLabel: {
                    show: yAxisLabels,
                    hideOverlap: true,
                    showMaxLabel: true,
                    formatter: function(value){
                            return formatAxisValue(value, yFormat, yUnitSummary)
                    },
                    margin: 4
                },
                min: yMin,
                max: yMax,
                splitLine: {
                    show: yGridlines
                },
                axisLine: {
                    show: yBaseline,
                    onZero: false
                },
                axisTick: {
                    show: yTickMarks
                },
                boundaryGap: false
            }
        } else {
            horizAxisConfig = {
                    type: xType,
                    splitLine: {
                        show: xGridlines
                    },
                    axisLine: {
                        show: xBaseline
                    },
                    axisTick: {
                        show: xTickMarks
                    },
                    axisLabel: {
                        show: xAxisLabels,
                        hideOverlap: true,
                        showMaxLabel: (xType === "category" || xType === "value"), // max label for ECharts' time axis is a stub - default for that is false
                        formatter: 
                            xType === 'time' ? false :                         
                            function(value){
                                return formatAxisValue(value, xFormat, xUnitSummary)
                            },
                        margin: 6
                    },
                    scale: true,
            } 
        } 


        if(swapXY){
            verticalAxisConfig = {
                type: xType, 
                inverse: "true",
                splitLine: {
                    show: xGridlines
                },
                axisLine: {
                    show: xBaseline
                },
                axisTick: {
                    show: xTickMarks
                },
                axisLabel: {
                    show: xAxisLabels,
                    hideOverlap: true,
                    // formatter: 
                    //     function(value){
                    //         return formatAxisValue(value, xFormat, xUnitSummary)
                    //     },
                },
                scale: true
            }
        } else {
            verticalAxisConfig = {
                    type: "value",
                    splitLine: {
                        show: yGridlines
                    },
                    axisLine: {
                        show: yBaseline,
                        onZero: false
                    },
                    axisTick: {
                        show: yTickMarks
                    },
                    axisLabel: {
                        show: yAxisLabels,
                        hideOverlap: true,
                        margin: 4,
                        formatter: function(value){
                            return formatAxisValue(value, yFormat, yUnitSummary)
                        }
                    },
                    name: yAxisTitle,
                    nameLocation: 'end',
                    nameTextStyle: {
                        align: 'left',
                        verticalAlign: 'top',
                        backgroundColor: 'white',
                        padding: [0,5,0,0]
                    },
                    nameGap: 6,
                    min: yMin,
                    max: yMax,
                    boundaryGap: ['0%', '1%'],
                }
        }

    // ---------------------------------------------------------------------------------------
    // Set up chart area
    // ---------------------------------------------------------------------------------------
        chartAreaHeight = 180; // standard height for chart area across all charts

        hasTitle = title ? true : false;
        hasSubtitle = subtitle ? true: false;
        hasLegend = legend * (series !== null || (typeof y === 'object' && y.length > 1));
        hasTopAxisTitle = yAxisTitle !== '' && swapXY;
        hasBottomAxisTitle = xAxisTitle !== '' && !swapXY;

        titleFontSize = 15;
        subtitleFontSize = 13;
        titleBoxPadding = 6 * (hasSubtitle);

        titleBoxHeight = (hasTitle * titleFontSize) + (hasSubtitle * subtitleFontSize) + (titleBoxPadding * Math.max(hasTitle, hasSubtitle));

        chartAreaPaddingTop = 10;
        chartAreaPaddingBottom = 8;

        bottomAxisTitleSize = 14;
        topAxisTitleSize = 14 + 0; // font size + padding top

        legendHeight = 15;
        legendHeight = legendHeight * hasLegend;

        legendPaddingTop = 7;
        legendPaddingTop = legendPaddingTop * Math.max(hasTitle, hasSubtitle);

        legendTop = titleBoxHeight + legendPaddingTop;
        chartTop = legendTop + legendHeight + (topAxisTitleSize * hasTopAxisTitle) + chartAreaPaddingTop;
        chartBottom = (hasBottomAxisTitle * bottomAxisTitleSize) + chartAreaPaddingBottom;
        chartContainerHeight = chartAreaHeight + chartTop + chartBottom;

        topAxisTitleTop = legendTop + legendHeight + 7;

        // Adjustment to avoid small bars on horizontal bar chart (extend chart height to accomodate)
        // Small bars are allowed on normal bar chart (e.g., time series bar chart)
        maxBars = 6;
        heightMultiplier = 1;
        if(swapXY){
            barCount = xDistinct.length;
            heightMultiplier = Math.max(1, barCount / maxBars);
        }

        // Set final chart height:
        height = (chartContainerHeight * heightMultiplier) + 'px';
        width = '100%';

    // ---------------------------------------------------------------------------------------
    // Set up horizontal axis title (custom graphic)
    // ---------------------------------------------------------------------------------------
        horizAxisTitle = swapXY ? yAxisTitle : xAxisTitle;
        if(horizAxisTitle !== ''){
            horizAxisTitle = horizAxisTitle + " \u2192"  // u2192 is js escaped version of &rarr;
        }
        
        horizAxisTitleConfig = {
                id: 'horiz-axis-title',
                type: 'text',
                style: {
                    text: horizAxisTitle,
                    textAlign: 'right',
                    fill: colours.grey500,
                },
                cursor: 'auto',
                // Positioning (if swapXY, top right; otherwise bottom right)
                right: swapXY ? '2%' : '3%',
                top: swapXY ? topAxisTitleTop : null,
                bottom: swapXY ? null: '2%'
            };

    // ---------------------------------------------------------------------------------------
    // Build chart config and update config store so child components can access it
    // ---------------------------------------------------------------------------------------
        chartConfig = {
            title: {
                text: title,
                subtext: subtitle,
                subtextStyle: {
                    width: width
                },
            },
            tooltip: {
                trigger: "axis",
                // formatter function is overridden in ScatterPlot, BubbleChart, and Histogram
                formatter: function(params){
                    let output
                    let xVal
                    let yVal
                    let yCol
                    if(params.length > 1){
                        // If multi-series, add series name as title of tooltip
                        xVal = params[0].value[swapXY ? 1 : 0]
                        output = `<span style='font-weight: 600;'>${formatValue(xVal, xFormat)}</span>`
                        for(let i = params.length - 1; i >= 0; i--){
                            yVal = params[i].value[swapXY ? 0 : 1]
                            output = output + `<br> ${params[i].marker} ${params[i].seriesName} <span style='float:right; margin-left: 10px;'>${formatValue(yVal, yFormat)}</span>`
                        }
                    } else if(xType === "value"){
                        // If single-series and a numerical x-axis, include x column as a normal column rather than title (so as not to show a number as the title)
                        xVal = params[0].value[swapXY ? 1 : 0]
                        yVal = params[0].value[swapXY ? 0 : 1]
                        yCol = params[0].seriesName
                        output = `<span style='font-weight: 600;'>${formatTitle(x, xFormat)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(xVal, xFormat)}</span><br/><span style='font-weight: 600;'>${formatTitle(yCol, yFormat)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(yVal, yFormat)}</span>`
                    } else {
                        // If single series and categorical or date x-axis, use x value as title of tooltip
                        xVal = params[0].value[swapXY ? 1 : 0]
                        yVal = params[0].value[swapXY ? 0 : 1]
                        yCol = params[0].seriesName
                        output = `<span style='font-weight: 600;'>${formatValue(xVal, xFormat)}</span><br/><span>${formatTitle(yCol, yFormat)}: </span><span style='float:right; margin-left: 10px;'>${formatValue(yVal, yFormat)}</span>`
                    }
                    return output
                },
                confine: true,
                axisPointer: {
                    // Use axis to trigger tooltip 
                    type: "shadow", // 'shadow' as default; can also be 'line' or 'shadow'

                },
                padding: 6,
                borderRadius: 4, 
                borderWidth: 1,
                borderColor: colours.grey400,
                backgroundColor: 'white',
                extraCssText: 'box-shadow: 0 3px 6px rgba(0,0,0,.15); box-shadow: 0 2px 4px rgba(0,0,0,.12); z-index: 1;',
                textStyle: {
                    color: colours.grey900,
                    fontSize: 12,
                    fontWeight: 400
                },
                order:'valueDesc'
            },
            legend: {
                show: legend,
                type: "scroll",
                top: legendTop,
                padding: [0, 0, 0, 0]
            },
            grid: {
                left: "0.5%",
                right: swapXY ? "4%" : "3%",
                bottom: chartBottom,
                top: chartTop,
                containLabel: true,
            },
            xAxis: horizAxisConfig,
            yAxis: verticalAxisConfig,
            series: [],
            animation: true,
            graphic: horizAxisTitleConfig
        };

        if(options){
            chartConfig = {...chartConfig, ...options}
        }

        config.update(d => { return chartConfig });

    } catch(e) {
        error = e.message;
        props.update(d => { return {...d, error} })
    }
}

$: data

</script>


{#if !error}

<slot></slot>
<ECharts config={$config} {height} {width} {data}/>

{:else}

<ErrorChart {error} {chartType}/>

{/if}